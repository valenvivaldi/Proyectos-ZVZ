<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - models/round.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>models/round.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">56.96</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">350</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">84.19</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.55</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">var mongoose= require(&#039;mongoose&#039;);


/*

 *
 * Represents a game&#039;s round
 *
 * @param gmae [Object]: game where the round belongs
 *
 */

var _ = require(&#039;lodash&#039;);
var StateMachine = require(&quot;../node_modules/javascript-state-machine/state-machine.js&quot;);
var deckModel = require(&quot;./deck&quot;);
var Deck  = deckModel.deck;

var playerModel = require(&quot;./player&quot;);
var Player = playerModel.player;



var RoundSchema= mongoose.Schema({
  currentTurn:Object,
  jugadorMano:Object,
  player1:Object,
  player2:Object, 
  fsm:Object,
  status:String,
  score:Array,
  cartasPrimerJugador:Array,
  cartasSegundoJugador:Array,
  jugadorCantoEnvido:Object,
  jugadorCantoTruco:Object,
  historialDeAcciones:Array,
  winnerOfRound : Object,

  ganadorPrimera:Object,
  ganadorSegunda:Object,
  ganadorTercera:Object

});

var Round = mongoose.model (&#039;Round&#039;,RoundSchema);

//function Round(game,turn){
  /*
   * Game
   */
  //this.game = game;

  /*
   * next turn
   */
  //this.currentTurn = turn;
  //this.jugadorMano = turn;
  

  //this.player1=game.player1;
  //this.player2=game.player2;
  /*
   * here is a FSM to perform user&#039;s actions
   */
  //this.fsm = newTrucoFSM();

  /*
   *
   */
  //this.status = &#039;running&#039;;

  /*
   * Round&#039; score
   */
  //this.score = game.score;



//cartas jugadas por los jugadores
 // this.cartasPrimerJugador=[];
  //this.cartasSegundoJugador=[];


  //this.jugadorCantoEnvido=undefined;
  //this.jugadorCantoTruco=undefined;

	//this.historialDeAcciones=[];
  //this.winnerOfRound = undefined;

  //this.ganadorPrimera;
  //this.ganadorSegunda;
  //this.ganadorTercera;




//}


/*
 * Generate a new deck mixed and gives to players the correspondent cards
 */
Round.prototype.deal = function(){
  var deck = new Deck().mix();

  this.player1.setCards(_.pullAt(deck, 0, 2, 4));
  this.player2.setCards(_.pullAt(deck, 1, 3, 5));

	this.player1.envidopoints =this.player1.points();
  	this.player2.envidopoints =this.player2.points();
};

/*
 * Calculates who is the next player to play.
 *
 * + if action is &#039;quiero&#039; or &#039;no-quiero&#039; and it&#039;s playing &#039;envido&#039; the next
 * player to play is who start to chant
 *
 * + if action is &#039;quiero&#039; or &#039;no-quiero&#039; and it&#039;s playing &#039;envido&#039; the next
 * player to play is who start to chant
 *
 * ToDo
 */
 Round.prototype.changeTurn = function(){
   this.currentTurn = this.switchPlayer(this.currentTurn);
}

/*
 * returns the oposite player
 */
Round.prototype.switchPlayer= function(player) {
  return this.player1.name === player.name ? this.player2 : this.player1;
};

/*
 * ToDo: Calculate the real score
 */
Round.prototype.calculateRealPoints =function(){
var puntosp1 = this.score[0] //+this.score[0];
var puntosp2 = this.score[1] //+this.score[1];

return [puntosp1,puntosp2];
}




Round.prototype.calculateScore = function(action){
  var accionAnterior = this.historialDeAcciones.length-2;
  console.log(&#039;LA ACCION ANTERIOR ES &#039;+this.historialDeAcciones[accionAnterior]);
  if(action == &quot;quiero&quot; &amp;&amp;this.historialDeAcciones[accionAnterior] ==&quot;envido&quot; ){
    console.log(this.player1.envidopoints);

    if (this.player1.envidopoints &lt;this.player2.envidopoints){this.score[1]=this.score[1]+2;console.log(&#039;aaaa&#039;);};
    if (this.player1.envidopoints &gt;this.player2.envidopoints){this.score[0]=this.score[0]+2;console.log(&#039;aaaa&#039;);};
    if (this.player1.envidopoints ==this.player2.envidopoints){this.cargarPuntosJugador(this.jugadorMano,2);};
    console.log(&#039;entro al if de envido - quiero&#039;);
  
  };
  if(action == &quot;no-quiero&quot; &amp;&amp;this.historialDeAcciones[accionAnterior] ==&quot;envido&quot; ){

    if (this.jugadorCantoEnvido.name == this.player1.name) {this.score[0]+=1;};
  	if (this.jugadorCantoEnvido.name == this.player2.name) {this.score[1]+=1;};
	this.currentTurn = this.switchPlayer(this.jugadorCantoEnvido);  
  };


//esto tendir que ser un callback en el no-quiero
  if(action == &quot;no-quiero&quot; &amp;&amp; this.historialDeAcciones[accionAnterior]==&quot;truco&quot;){
    this.cargarPuntosJugador(this.jugadorCantoTruco,1);
    this.winnerOfRound=this.jugadorCantoTruco;
    this.fsm[&quot;fin-ronda&quot;]();
    
  };
  var aux = this.calculateRealPoints();  //verificamos que alguno haya llegado a los treinta por haber ganado el envido
  if (aux[0]&gt;=30 || aux[1]&gt;=30){this.fsm[&quot;fin-ronda&quot;](this)};



  return this.score;
}

/*
 * Let&#039;s Play :)
 */
Round.prototype.play = function(action, value) {
  


  // move to the next state
  
  this.fsm[action]();
  
  this.historialDeAcciones.push(action);
  	
  // check if is needed sum score
  this.calculateScore(action);


	if(action==&quot;play-card&quot;){
		console.log(&#039;ENTRA EN LA ACCION DE PLAY CARD&#039;);
    console.log(value);
    this.seJuegaCarta(value);
		this.verificarGanador();
	}


  // Change player&#039;s turn
  return this.changeTurn();
// Muestra puntos actuales del juego 

};

Round.prototype.cargarPuntosJugador = function(player,puntos){
if (player.name ==this.player1.name){this.score[0]+=puntos;}
if (player.name ==this.player2.name){this.score[1]+=puntos;}

}

Round.prototype.showRealPoints = function (){
console.log (&#039;El jugador:&#039;+this.player1.getname()+&#039; tiene &#039;+this.score[0]+&#039; actualmente \n&#039;);
console.log (&#039;El jugador:&#039;+this.player2.getname()+&#039; tiene &#039;+this.score[1]+&#039; actualmente \n&#039;);
} 

Round.prototype.seJuegaCarta=function(carta){

for (var i=0; i &lt; 3; i++) { 

if((this.player1.cards[i]!=undefined)&amp;&amp;(this.player1.cards[i].suit==carta.suit)&amp;&amp;(this.player1.cards[i].number==carta.number)){
  this.player1.cards.splice(i,1);
  this.cartasPrimerJugador[this.cartasPrimerJugador.length]=carta;
  };

if((this.player2.cards[i]!=undefined)&amp;&amp;(this.player2.cards[i].suit==carta.suit)&amp;&amp;(this.player2.cards[i].number==carta.number)){
  this.player2.cards.splice(i,1);
  this.cartasSegundoJugador[this.cartasSegundoJugador.length]=carta;
  };

}

};

Round.prototype.checkWinnerOfRound =function(){
  var aux;




	if (this.cartasPrimerJugador.length&gt;=1&amp;&amp;this.cartasSegundoJugador.length&gt;=1){	
  if(this.cartasPrimerJugador[0].weight &lt;this.cartasSegundoJugador[0].weight){this.ganadorPrimera=this.player2.name;};
  if(this.cartasPrimerJugador[0].weight &gt;this.cartasSegundoJugador[0].weight){this.ganadorPrimera=this.player1.name;};
  if(this.cartasPrimerJugador[0].weight == this.cartasSegundoJugador[0].weight){this.ganadorPrimera=&quot;Pardas&quot;;};
	}


  if (this.cartasPrimerJugador.length&gt;=2&amp;&amp;this.cartasSegundoJugador.length&gt;=2){
  if(this.cartasPrimerJugador[1].weight &lt;this.cartasSegundoJugador[1].weight){this.ganadorSegunda=this.player2.name;};
  if(this.cartasPrimerJugador[1].weight &gt;this.cartasSegundoJugador[1].weight){this.ganadorSegunda=this.player1.name;};
  if(this.cartasPrimerJugador[1].weight ==this.cartasSegundoJugador[1].weight){this.ganadorSegunda=&quot;Pardas&quot;;};
    

  };
  

  if (this.cartasPrimerJugador.length==3&amp;&amp;this.cartasSegundoJugador.length==3){
  if(this.cartasPrimerJugador[2].weight &lt;this.cartasSegundoJugador[2].weight){this.ganadorTercera=this.player2.name;};
  if(this.cartasPrimerJugador[2].weight &gt;this.cartasSegundoJugador[2].weight){this.ganadorTercera=this.player1.name;};
  if(this.cartasPrimerJugador[2].weight ==this.cartasSegundoJugador[2].weight){this.ganadorTercera=&quot;Pardas&quot;;};
  };


  if ((this.cartasPrimerJugador.length==1&amp;&amp;this.cartasSegundoJugador.length==1)&amp;&amp; (this.ganadorPrimera!=&quot;Pardas&quot;)){
  	aux = new Player({name:this.ganadorPrimera});

    this.currentTurn = this.switchPlayer(aux);
  };
  if ((this.cartasPrimerJugador.length==2&amp;&amp;this.cartasSegundoJugador.length==2)&amp;&amp; (this.ganadorSegunda!=&quot;Pardas&quot;)){
  	 aux = new Player({name:this.ganadorSegunda});
    this.currentTurn = this.switchPlayer(aux);
   };





  if ((this.cartasPrimerJugador.length==2)&amp;&amp;(this.cartasSegundoJugador.length==2)){
    if ((this.ganadorPrimera==this.ganadorSegunda)&amp;&amp;(this.ganadorPrimera!=&quot;Pardas&quot;)){return this.ganadorPrimera;};
    if ((this.ganadorPrimera==&quot;Pardas&quot; )&amp;&amp;(this.ganadorSegunda!=&quot;Pardas&quot;)){return this.ganadorSegunda;};
    if ((this.ganadorPrimera!=&quot;Pardas&quot;)&amp;&amp;(this.ganadorSegunda==&quot;Pardas&quot;)){return this.ganadorPrimera;};
  };



  if (this.cartasPrimerJugador.length==3&amp;&amp;this.cartasSegundoJugador.length==3){


    if ((this.ganadorPrimera==this.ganadorSegunda)&amp;&amp;(this.ganadorTercera!=&quot;Pardas&quot;)){return this.ganadorTercera;};
    if ((this.ganadorPrimera==this.ganadorSegunda)&amp;&amp;(this.ganadorTercera==&quot;Pardas&quot;)){return this.jugadorMano;};
     if ((this.ganadorPrimera!=&quot;Pardas&quot;)&amp;&amp;(this.ganadorSegunda!=&quot;Pardas&quot;)){
        if (this.ganadorTercera==&quot;Pardas&quot;){return this.ganadorPrimera;};
        return this.ganadorTercera;

     }; 
  }

  

return undefined;

};

Round.prototype.puntosDelTruco=function(){
if(this.jugadorCantoTruco == undefined){return 1;
}
return 2;
};

Round.prototype.verificarGanador = function(){
	this.winnerOfRound = this.checkWinnerOfRound();
 	if (this.winnerOfRound){
 		console.log(&#039;ENCONTRO UN  GNADOR!&#039;);
    var aux = new Player({name:this.winnerOfRound});
    this.cargarPuntosJugador(aux,this.puntosDelTruco());
    this.fsm[&#039;fin-ronda&#039;]();

}
};


Round.prototype.newTrucoFSM = function(estadoactual){
  var fsm = StateMachine.create({
  initial: &#039;init&#039;,
  events: [
    { name: &#039;play-card&#039;, from: &#039;init&#039;,                           to: &#039;primer-carta&#039; },
    { name: &#039;envido&#039;,    from: [&#039;init&#039;, &#039;primer-carta&#039;],         to: &#039;envido&#039; },
    { name: &#039;truco&#039;,     from: [&#039;init&#039;, &#039;played-card&#039;],          to: &#039;truco&#039;  },
    { name: &#039;play-card&#039;, from: [&#039;quiero&#039;, &#039;no-quiero&#039;,
                                &#039;primer-carta&#039;, &#039;played-card&#039;],  to: &#039;played-card&#039; },
    { name: &#039;quiero&#039;,    from: [&#039;envido&#039;, &#039;truco&#039;],              to: &#039;quiero&#039;  },
    { name: &#039;no-quiero&#039;, from: [&#039;envido&#039;, &#039;truco&#039;],              to: &#039;no-quiero&#039; },
    
    { name: &#039;fin-ronda&#039;, from: [&#039;played-card&#039;,&#039;no-quiero&#039;],      to:&#039;estado-final&#039; },  
  ] 
  });
  if(estadoactual!=undefined){fsm.current=estadoactual;};
  return fsm;
}



module.exports.round = Round;</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
